<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gradation_line</title>
</head>
<body>
    <h1>グラデーション ライン</h1>

    <canvas id="my-canvas" width="300" height="300"></canvas>

    <form>
        <label for="my-radio-0">
            <input type="radio" id="my-radio-0" name="my-radio" value="normal"> ノーマル
        </label>
        <label for="my-radio-1">
            <input type="radio" id="my-radio-1" name="my-radio" value="polygon" checked> グラデーション
        </label>
    </form>

    <script>
        let canvas = document.getElementById('my-canvas');
        let radios = document.getElementsByName('my-radio');
        let ctx = canvas.getContext('2d', { alpha: false });
        let anime = null; // アニメーション
        let time = (new Date()).getTime(); // 処理フレームの時刻。
        let px0 = 0, py0 = 5, px1 = 50, py1 = 50; // 線の位置
        let vx0 = 30, vy0 = -80, vx1 = 80, vy1 = -20; // 線の頂点の速度

        /**
         * 指定された2点間に線分を描画する。
         * この関数は、描画スタイル（色や太さ）の設定は行わず、パスの定義と実行のみを行う。
         * * @param {CanvasRenderingContext2D} ctx - 描画に使用するCanvas 2Dコンテキスト。
         * @param {number} x0 - 始点 (P0) のX座標。
         * @param {number} y0 - 始点 (P0) のY座標。
         * @param {number} x1 - 終点 (P1) のX座標。
         * @param {number} y1 - 終点 (P1) のY座標。
         */
        const drawLine = (ctx, x0, y0, x1, y1) => {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        };

        /**
         * 2点間に幅を持った線（矩形ポリゴン）を描画し、その幅に対して垂直方向のグラデーションを適用する。
         * これにより、線の中心が最も濃く、端に向かって色が薄くなる（または透明になる）視覚効果が得られる。
         * * @param {CanvasRenderingContext2D} ctx - 描画に使用するCanvas 2Dコンテキスト。
         * @param {number} x0 - 始点 (P0) のX座標。
         * @param {number} y0 - 始点 (P0) のY座標。
         * @param {number} x1 - 終点 (P1) のX座標。
         * @param {number} y1 - 終点 (P1) のY座標。
         * @param {string} [centerColor=ctx.strokeStyle] - 線の中心に適用する色。指定がない場合は現在の strokeStyle を使用。
         * @param {string} [edgeColor='rgba(0, 0, 0, 0%)'] - 線の両端（エッジ）に適用する色（通常は透明）。
         */
        const drawLineWithGradation = (ctx, x0, y0, x1, y1, centerColor = ctx.strokeStyle, edgeColor = 'rgba(0, 0, 0, 0%)') => {
            const halfWidth = ctx.lineWidth / 2; // 半分の幅
            // 1. 方向ベクトルの計算
            const dx = x1 - x0, dy = y1 - y0;
            // 2. 法線ベクトルの計算 (時計回りに90度回転)
            const nx = dy, ny = -dx;
            // 法線ベクトルを正規化（長さ1にする）
            const len = Math.sqrt(nx * nx + ny * ny);
            const normX = nx / len, normY = ny / len;
            // 3. 矩形の4つの頂点を計算
            // 始点P1から法線方向に +/- halfWidth オフセット
            const p0x = x0 + normX * halfWidth;
            const p0y = y0 + normY * halfWidth;
            const p1x = x0 - normX * halfWidth;
            const p1y = y0 - normY * halfWidth;
            // 終点P2から法線方向に +/- halfWidth オフセット
            const p2x = x1 - normX * halfWidth;
            const p2y = y1 - normY * halfWidth;
            const p3x = x1 + normX * halfWidth;
            const p3y = y1 + normY * halfWidth;
            // 4. 頂点を結んで多角形を作成
            ctx.beginPath();
            ctx.moveTo(p0x, p0y);
            ctx.lineTo(p1x, p1y);
            ctx.lineTo(p2x, p2y);
            ctx.lineTo(p3x, p3y);
            ctx.closePath();
            // 5. グラデーションの作成
            // 線の端（グラデーションの開始点と終了点）
            // 線の中心から法線ベクトルの方向に halfWidth 分オフセットした点
            const gradStartPointX = x0 - normX * halfWidth;
            const gradStartPointY = y0 - normY * halfWidth;
            const gradEndPointX = x0 + normX * halfWidth;
            const gradEndPointY = y0 + normY * halfWidth;
            const gradient = ctx.createLinearGradient(
                gradStartPointX, gradStartPointY,
                gradEndPointX, gradEndPointY);
            // 中心 (40%～60%)
            gradient.addColorStop(0.4, centerColor);
            gradient.addColorStop(0.6, centerColor);
            // 端 (0% と 100%)
            gradient.addColorStop(0.0, edgeColor);
            gradient.addColorStop(1.0, edgeColor);
            // 5. 塗りつぶし
            ctx.fillStyle = gradient;
            ctx.fill();
        };

        // 描画する関数
        const render = () => {
            // キャンバスのサイズ
            let width = canvas.width, height = canvas.height;
            // 経過時間を計算
            let new_time = (new Date()).getTime();
            let diff_time = (new_time - time) / 1000.0; // 秒単位
            time = new_time; // 時刻を更新

            // 黒で塗りつぶす
            ctx.clearRect(0, 0, width, height);

            // 線の位置を動かす
            px0 += vx0 * diff_time;
            py0 += vy0 * diff_time;
            px1 += vx1 * diff_time;
            py1 += vy1 * diff_time;

            // カベに当たったら跳ね返る
            if (px0 < 0) { px0 = 0; vx0 = -vx0; }
            if (px1 < 0) { px1 = 0; vx1 = -vx1; }
            if (py0 < 0) { py0 = 0; vy0 = -vy0; }
            if (py1 < 0) { py1 = 0; vy1 = -vy1; }
            if (px0 > width) { px0 = width; vx0 = -vx0; }
            if (px1 > width) { px1 = width; vx1 = -vx1; }
            if (py0 > height) { py0 = height; vy0 = -vy0; }
            if (py1 > height) { py1 = height; vy1 = -vy1; }

            // 線を描く
            ctx.lineWidth = 30;
            console.assert(radios.length == 2);
            const is_polygon = radios[1].checked;
            ctx.strokeStyle = 'red';
            if (is_polygon) {
                ctx.lineWidth *= 2.5; // グラデーションを付けると細く見えるので補正する。
                drawLineWithGradation(ctx, px0, py0, px1, py1);
            } else {
                drawLine(ctx, px0, py0, px1, py1);
            }

            // 次のアニメーションフレームを要求する
            if (anime)
                anime = window.requestAnimationFrame(render);
        };

        // アニメーションを開始する
        anime = window.requestAnimationFrame(render);
    </script>
</body>
</html>